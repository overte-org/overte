//
//  PathUtils.h
//  libraries/shared/src
//
//  Created by Brad Hefta-Gaub on 12/15/14.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

#ifndef hifi_PathUtils_h
#define hifi_PathUtils_h

#include <QtCore/QObject>
#include <QtCore/QUrl>
#include <QtCore/QDir>
#include <mutex>
#include "DependencyManager.h"

#include <QLoggingCategory>
Q_DECLARE_LOGGING_CATEGORY(pathutils_log)


/**
 * @brief Path handling functions
 *
 * Overte and its components need to be portable and to run under multiple possible scenarios. The code here takes
 * care of returning correct paths based on the operating system, environment and other factors.
 *
 * We have two big concerns here: locating our static data, and locating our dynamic data and settings.
 *
 * For static data there are two possibilities:
 *
 * 1. We're running from the build tree.
 * 2. We're running from a Linux FHS layout (/usr/bin, /var, etc)
 *
 * In both cases we locate everything relative to our current position. Paths are not hardcoded to eg, /var, but
 * resolved to $BINARY_DIR/../var. This means things work correcly in /usr/local as well, and in untarred builds.
 * This also works to make testing this code easier, since it doesn't need to be in the system root.
 *
 *
 * For dynamic data there's also two possibilities:
 *
 * 1. We're using system-wide configuration directories (/etc, var)
 * 2. We're using $HOME of the current user.
 *
 * Some combinations don't make sense for some of the code. Interface shouldn't write to /etc because it's a program
 * run by a desktop user.
 *
 * @note General design notes:
 *
 * 1. Everything is initialized once in initialize(). We don't do runtime changes.
 * 2. No getenv() after initialize(). It's not thread safe.
 * 3. No getenv() when possible, this should work right out of the box. If customization is needed it's probably a bug.
 *
 *
 */
class PathUtils : public QObject, public Dependency {
    Q_OBJECT
    SINGLETON_DEPENDENCY
    Q_PROPERTY(QString resources READ resourcesPath CONSTANT)
    Q_PROPERTY(QUrl defaultScripts READ defaultScriptsLocation CONSTANT)
public:


    /**
     * @brief What filesystem layout is in use
     *
     */
    enum class FilesystemLayout {
        /**
         * @brief Auto-detect. If used, will be automatically changed to one of the ones below.
         *
         */
        Auto,

        /**
         * @brief Linux Filesystem Hierarchy Standard
         *
         * Autodetected by checking that the binary is within a 'bin' directory.
         *
         * Paths are established relative to the bin directory. For instance, var
         * is located as '$BINARY_DIR/../var', so if the binary is in /usr/local/bin,
         * then data is put into /usr/local/var.
         *
         * This also allows untarring a full install and running from the extracted
         * location.
         *
         * See https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.html
         *
         */
        FHS,

        /**
         * @brief Running from the build directory
         *
         * This uses the layout generated by CMake.
         */
        BuildDir,

        /**
         * @brief Running from the build directory, using resources from the source tree.
         *
         * Same as BuildDir, but instead of requiring resources to be copied over, they're
         * read directly from the source dir by following a symbolic link created by CMake.
         *
         * @note This is never auto-detected, it must be selected manually.
         *
         */
        BuildDirSourceResources
    };


    Q_ENUM(FilesystemLayout)

    enum class DataStorage {
        /**
         * @brief Automatically determine where to store the settings and data
         *
         */
        Auto,

        /**
         * @brief Store the settings and data in system directories like /etc and /var
         *
         */
        System,

        /**
         * @brief Store the settings and data in the user's home directory
         *
         */
        Home
    };

    Q_ENUM(DataStorage)


    /**
     * @brief Force the system back into an un-initialized state
     *
     * @warning This is only to be used in test scripts, where multiple initializations are desirable.
     */
    static void uninitialize();

    /**
     * @brief Initialize the path system
     *
     * This will be automatically called internally with the default arguments if not done.
     *
     * @param type Type of filesystem layout
     * @param ds  Type of data storage
     * @param instance Instance name
     *
     * @return true Self-check passed, all paths look good.
     * @return false Something isn't being found, program should abort.
     */
    static bool initialize(FilesystemLayout type = FilesystemLayout::Auto, DataStorage ds = DataStorage::Auto, const QString &instance = "main");



    /**
     * @brief Get get path to the Qt Resource file
     *
     * The RCC file contains data such as scripts and textures
     *
     * @return const QString& Path to file
     */
    static const QString& getRccPath();


    /**
     * @brief Get the URL to static resources
     *
     * This normally returns just qrc://, directing things towards the contents of the rcc file.
     *
     * However, the RCC file can also be ignored when using out of tree resources, so in this case
     * it'll return a path pointing to the filesystem instead.
     *
     * @return const QString& URL
     */
    static const QString& resourcesUrl();


    /**
     * @brief Get the URL to a particular static resourcec
     *
     * Returns a path relative to resourcesUrl(), this is a convenience function.
     *
     * @param relative Relative path
     * @return QUrl URL consisting of resourcesUrl()/relative
     */
    static QUrl resourcesUrl(const QString& relative);


    /**
     * @brief Get the base path for static resources
     *
     * Like resourcesUrl(), but this points to a local file path instead
     *
     * This returns ":/" by default, which is a special value used by the Qt resources system: https://doc.qt.io/qt-5/resources.html
     *
     * @note It's not quite clear to me whether this is redundant with resourcesUrl
     *
     * @return const QString& Base path, by default ":/"
     */
    static const QString& resourcesPath();

    /**
     * @brief Returns the base URL for QML
     *
     * This is resourcesUrl()/qml/
     *
     * @return const QString& QML base URL
     */

    static const QString& qmlBaseUrl();
    static QUrl expandToLocalDataAbsolutePath(const QUrl& fileUrl);


    /**
     * @brief URL to a QML document
     *
     * This is calculated relative to qmlBaseUrl()
     * @param relative Relative path
     * @return QUrl URL pointing to qmlBaseUrl()/relative
     */
    static QUrl qmlUrl(const QString& relative);
#ifdef DEV_BUILD
    static const QString& projectRootPath();
#endif

    static QString getAppDataPath();
    static QString getAppLocalDataPath();

    static QString getAppDataFilePath(const QString& filename);
    static QString getAppLocalDataFilePath(const QString& filename);

    static QString generateTemporaryDir();
    static bool deleteMyTemporaryDir(QString dirName);

    static int removeTemporaryApplicationDirs(QString appName = QString());

    static Qt::CaseSensitivity getFSCaseSensitivity();
    static QString stripFilename(const QUrl& url);
    // note: this is FS-case-sensitive version of parentURL.isParentOf(childURL)
    static bool isDescendantOf(const QUrl& childURL, const QUrl& parentURL);
    static QUrl defaultScriptsLocation(const QString& newDefault = "");


    /**
     * @brief Set the Server Name
     *
     * The server name is used as a component of paths to allow for multiple instances to run on the same machine.
     * The default name is "main".
     *
     * For instance, by default the server-wide config files will be in "/etc/overte/main".
     * Starting a second instance with a server name of "bob" will result in a domain that loads the config from "/etc/overte/bob"
     *
     * @param server_name
     */
    //static void setInstanceName(const QString& server_name);

    /**
     * @brief Get the instance name
     *
     * This allows running multiple clients or servers concurrently, by giving each instance a name.
     * The name is purely descriptive and carries no meaning.
     *
     * The default instance name is 'main'.
     *
     * @return QString Current instance name
     */
    static QString getInstanceName();


    static QString getDataPath();

    static QString getServerDataPath();
    static QString getServerDataFilePath(const QString& filename);


    static void setResourcesPath(const QString &resource_dir);

    /**
     * @brief Return the path to the config file
     *
     * On Linux this will return a path within /etc in system mode.
     *
     * @param filename Configuration filename
     * @return QString
     */
    static QString getConfigFilePath(const QString &filename);

    /**
     * @brief Get the location of the describe-settings.json
     * The server name doesn't affect this function, this data is static and shared between instances.
     *
     * @return QString Location of describe-settings.json
     */
    static QString getSettingsDescriptionPath();

    static QString getAccountFileDirPath();

    /**
     * @brief Get the location of a server content directory
     *
     * This finds resource directories like 'web' or 'prometheus_exporter'.
     * The server name doesn't affect this function, this data is static and shared between instances.
     *
     * @param dir_name Directory being sought
     * @return QString  Location of the directory
     */
    static QString getServerContentPath(const QString &dir_name);


    /**
     * @brief Get the path of the plugins
     *
     * @return QString Path to the plugins directory
     */
    static QString getPluginsPath();

private:
    /**
     * @brief Initializes the default values
     *
     * Sets the paths to the default ones detected for the system. This may be overriden later from code.
     * Only runs once.
     *
     * The priority order is:
     * 1. Command-like argument (not handled in this function)
     * 2. Environment variable
     * 3. System-wide path (eg, /usr/share/vircadia). Linux only.
     * 4. Path relative to the executable's location
     *
     * We can operate in one of 3 modes:
     * 1. Everything is relative to the binary's position. This is used for running out of the source
     *    tree and on Windows and MacOS.
     * 2. Using Linux system paths for everything. Binary is in /usr/bin, data is in /var/lib/vircadia,
     *    configuration is in /etc/vircadia. This is enabled when isSystemUser() is true.
     * 3. Using Linux system paths for static data, home directory for user/dynamic data. This is used
     *    for the interface. This is enabled when isSystemInstall() is true.
     */
    //static void initialize();

    /**
     * @brief Given a list of paths, find the first one that exists
     *
     * @param paths Paths to check
     * @param description Description of the kind of path being sought, for error messages
     * @return QString Found path or empty string
     */
    static QString findFirstDir(const QStringList &paths, const QString &description);

    /**
     * @brief Given a list of paths, find the first one that exists
     *
     *
     * @param base Base path
     * @param subpaths Paths relative to base to check
     * @param description Description of the kind of path being sought, for error messages
     * @return QString Found path or empty string
     */
    static QString findFirstDir(const QString &base, const QStringList &subpaths, const QString &description);


    static QString makePath(const QStringList &paths, bool create=false);

    // Name for our server instance. This allows us to run multiple instances on the same machine.
    static QString _instance_name;

    // Location of static resources, /usr/share in Linux
    static QString _static_resources_path;

    // Location of the static server resources directory. This is where the 'web' content is found.
    static QString _server_resources_path;

    // Location of the configuration. This may be written by the code
    static QString _config_path;

    // Location of the writable data files
    static QString _appdata_path;

    // Location of the local writable data files
    static QString _local_appdata_path;

    // Location of assignment client plugins
    static QString _plugins_path;

    // Location of default scripts for the interface
    static QString _default_scripts_path;

    static bool _initialized;
    static std::mutex _lock;

};

QString fileNameWithoutExtension(const QString& fileName, const QVector<QString> possibleExtensions);
QString findMostRecentFileExtension(const QString& originalFileName, QVector<QString> possibleExtensions);

#endif // hifi_PathUtils_h
