<@include gpu/Config.slh@>
<$VERSION_HEADER$>
// <$_SCRIBE_FILENAME$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Eric Levin on 7/20/15.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/ShaderConstants.h@>

INPUT(GPU_ATTR_POSITION, vec4, inPosition);
INPUT(GPU_ATTR_NORMAL, vec4, inNormal);
INPUT(GPU_ATTR_COLOR, vec4, inColor);
INPUT(GPU_ATTR_TEXCOORD0, vec4, inTexCoord0);

<@include gpu/Color.slh@>
<@include gpu/Transform.slh@>
<$declareStandardTransform()$>

<@include paintStroke.slh@>
<$declarePolyLineBuffers()$>

OUTPUT(0, vec3, _normalWS);
OUTPUT(1, vec2, _texCoord);
OUTPUT(2, vec4, _color);
OUTPUT(3, float, _distanceFromCenter);

void main(void) {
    PolylineVertex vertex = getPolylineVertex(gl_VertexID / 2);
    float evenVertex = float(gl_VertexID % 2 == 0);

    _texCoord = vec2(vertex.positionAndUCoord.w, mix(1.0, 0.0, evenVertex));
    _color = color_sRGBAToLinear(vertex.color);

    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();
    _distanceFromCenter = -1.0 + 2.0 * evenVertex;
    vec4 position = vec4(vertex.positionAndUCoord.xyz, 1.0);
    vec3 binormal = vertex.binormalAndHalfWidth.xyz;
    if (_polylineData.faceCameraGlow.x != 0.0) {
        vec4 posEye;
        vec3 tangentEye;
        <$transformModelToEyePos(cam, obj, position, posEye)$>
        // See comment in RenderablePolyLineEntityItem.cpp: we actually pass in the tangent in faceCamera mode
        <$transformModelToEyeDir(cam, obj, binormal, tangentEye)$>

        // new normal faces the camera
        vec3 normalEye = normalize(posEye.xyz);

        vec3 binormalEye = normalize(cross(normalEye, tangentEye));
        posEye.xyz += _distanceFromCenter * vertex.binormalAndHalfWidth.w * binormalEye;
        <$transformEyeToClipPos(cam, posEye, gl_Position)$>
        <$transformEyeToWorldDir(cam, normalEye, _normalWS)$>
    } else {
        vec3 normal = vertex.normal.xyz;
        position.xyz += _distanceFromCenter * vertex.binormalAndHalfWidth.w * binormal;
        <$transformModelToClipPos(cam, obj, position, gl_Position)$>
        <$transformModelToWorldDir(cam, obj, normal, _normalWS)$>
    }
}
