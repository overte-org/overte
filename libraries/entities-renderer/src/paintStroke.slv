<@include gpu/Config.slh@>
<$VERSION_HEADER$>
// <$_SCRIBE_FILENAME$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Eric Levin on 7/20/15.
//  Copyright 2014 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include gpu/ShaderConstants.h@>
layout(location=GPU_ATTR_POSITION) in vec4 inPosition;
layout(location=GPU_ATTR_NORMAL) in vec4 inNormal;
layout(location=GPU_ATTR_COLOR) in vec4 inColor;
layout(location=GPU_ATTR_TEXCOORD0) in vec4 inTexCoord0;

<@include gpu/Color.slh@>
<@include gpu/Transform.slh@>
<$declareStandardTransform()$>

<@include paintStroke.slh@>
<$declarePolyLineBuffers()$>

<@if not HIFI_USE_FORWARD@>
    layout(location=0) out vec3 _normalWS;
<@endif@>
layout(location=1) out vec2 _texCoord;
layout(location=2) out vec4 _color;
layout(location=3) out float _distanceFromCenter;

void main(void) {
    PolylineVertex vertex = getPolylineVertex(gl_VertexID / 2);
    float evenVertex = float(gl_VertexID % 2 == 0);

    _texCoord = vec2(vertex.positionAndUCoord.w, mix(1.0, 0.0, evenVertex));
    _color = color_sRGBAToLinear(vertex.color);

    TransformCamera cam = getTransformCamera();
    TransformObject obj = getTransformObject();
    _distanceFromCenter = -1.0 + 2.0 * evenVertex;
    vec4 position = vec4(vertex.positionAndUCoord.xyz, 1.0);
    vec3 binormal = vertex.binormalAndHalfWidth.xyz;
    if (_polylineData.faceCameraGlow.x != 0.0) {
        vec4 posEye;
        vec3 tangentEye;
        <$transformModelToEyePos(cam, obj, position, posEye)$>
        // See comment in RenderablePolyLineEntityItem.cpp: we actually pass in the tangent in faceCamera mode
        <$transformModelToEyeDir(cam, obj, binormal, tangentEye)$>

        // new normal faces the camera
        vec3 normalEye = normalize(posEye.xyz);

        vec3 binormalEye = normalize(cross(normalEye, tangentEye));
        // Workaround for Nvidia driver bug
        posEye.x += _distanceFromCenter * vertex.binormalAndHalfWidth.w * binormalEye.x;
        posEye.y += _distanceFromCenter * vertex.binormalAndHalfWidth.w * binormalEye.y;
        posEye.z += _distanceFromCenter * vertex.binormalAndHalfWidth.w * binormalEye.z;
        <$transformEyeToClipPos(cam, posEye, gl_Position)$>
<@if not HIFI_USE_FORWARD@>
        <$transformEyeToWorldDir(cam, normalEye, _normalWS)$>
<@endif@>
    } else {
        vec3 normal = vertex.normal.xyz;
        position.xyz += _distanceFromCenter * vertex.binormalAndHalfWidth.w * binormal;
        <$transformModelToClipPos(cam, obj, position, gl_Position)$>
<@if not HIFI_USE_FORWARD@>
        <$transformModelToWorldDir(cam, obj, normal, _normalWS)$>
<@endif@>
    }
}