<@include gpu/Config.slh@>
<$VERSION_HEADER$>
//  <$_SCRIBE_FILENAME$>
//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Andrzej Kapolka on 5/6/14.
//  Copyright 2014 High Fidelity, Inc.
//  Copyright 2024 Overte e.V.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

<@include graphics/Material.slh@>
<@include graphics/MaterialTextures.slh@>
<@include render-utils/ShaderConstants.h@>
<@include CullFace.slh@>

<@if HIFI_USE_MTOON@>
    <@if HIFI_USE_SHADOW@>
        <$declareMToonMaterialTextures(ALBEDO)$>
    <@else@>
        <$declareMToonMaterialTextures(ALBEDO, HIFI_USE_NORMALMAP, SHADE, EMISSIVE, SHADING_SHIFT, MATCAP, RIM, UV_ANIMATION_MASK)$>
    <@endif@>
<@else@>
    <@if HIFI_USE_SHADOW or HIFI_USE_UNLIT@>
        <$declareMaterialTextures(ALBEDO)$>
    <@else@>
        <@if not HIFI_USE_LIGHTMAP@>
            <@if HIFI_USE_TRANSLUCENT@>
                <$declareMaterialTextures(ALBEDO, ROUGHNESS, HIFI_USE_NORMALMAP, METALLIC, EMISSIVE, OCCLUSION)$>
            <@else@>
                <$declareMaterialTextures(ALBEDO, ROUGHNESS, HIFI_USE_NORMALMAP, METALLIC, EMISSIVE, OCCLUSION, SCATTERING)$>
            <@endif@>
        <@else@>
            <$declareMaterialTextures(ALBEDO, ROUGHNESS, HIFI_USE_NORMALMAP, METALLIC)$>
            <$declareMaterialLightmap()$>
        <@endif@>
    <@endif@>
<@endif@>

<@if not HIFI_USE_SHADOW@>
    <@if HIFI_USE_MTOON@>

        <@include DefaultMaterials.slh@>
        <@include GlobalLight.slh@>
        <$declareEvalGlobalLightingAlphaBlendedMToon()$>

        <@include gpu/Transform.slh@>
        <$declareStandardCameraTransform()$>

        <@if HIFI_USE_FORWARD or HIFI_USE_TRANSLUCENT@>
            layout(location=0) out vec4 _fragColor0;
        <@else@>
            <@include DeferredBufferWrite.slh@>
        <@endif@>
    <@elif HIFI_USE_FORWARD or HIFI_USE_TRANSLUCENT@>
        <@include DefaultMaterials.slh@>
        <@include GlobalLight.slh@>
        <@if HIFI_USE_LIGHTMAP@>
            <$declareEvalLightmappedColor()$>
        <@elif HIFI_USE_TRANSLUCENT@>
            <@if not HIFI_USE_FORWARD@>
                <@include LightLocal.slh@>
            <@endif@>
            <$declareEvalGlobalLightingAlphaBlended()$>
        <@else@>
            <$declareEvalSkyboxGlobalColor(_SCRIBE_NULL, HIFI_USE_FORWARD)$>
        <@endif@>
        <@include gpu/Transform.slh@>
        <$declareStandardCameraTransform()$>
        OUTPUT(0, vec4, _fragColor0);
    <@else@>
        <@include DeferredBufferWrite.slh@>
    <@endif@>
<@else@>
    OUTPUT(0, vec4, _fragColor0);
<@endif@>

<@if HIFI_USE_UNLIT@>
    <@include LightingModel.slh@>
<@endif@>

<@if HIFI_USE_FADE@>
    <@include Fade.slh@>
    <$declareFadeFragment()$>
<@endif@>

INPUT(RENDER_UTILS_ATTR_POSITION_WS, vec4, _positionWS);
INPUT(RENDER_UTILS_ATTR_TEXCOORD01, vec4, _texCoord01);
#define _texCoord0 _texCoord01.xy
#define _texCoord1 _texCoord01.zw
<@if not HIFI_USE_SHADOW@>
    INPUT(RENDER_UTILS_ATTR_POSITION_ES, vec4, _positionES);
    INPUT(RENDER_UTILS_ATTR_NORMAL_WS, vec3, _normalWS);
    <@if not HIFI_USE_MTOON@>
        INPUT(RENDER_UTILS_ATTR_COLOR, vec4, _color);
    <@endif@>
    <@if HIFI_USE_NORMALMAP@>
        INPUT(RENDER_UTILS_ATTR_TANGENT_WS, vec3, _tangentWS);
    <@endif@>
<@endif@>

void main(void) {
<@if HIFI_USE_FADE@>
    <@if not HIFI_USE_SHADOW@>
        vec3 fadeEmissive;
        FadeObjectParams fadeParams;
        <$fetchFadeObjectParams(fadeParams)$>
        applyFade(fadeParams, _positionWS.xyz, fadeEmissive);
    <@else@>
        FadeObjectParams fadeParams;
        <$fetchFadeObjectParams(fadeParams)$>
        applyFadeClip(fadeParams, _positionWS.xyz);
    <@endif@>
<@endif@>

    Material mat = getMaterial();
    BITFIELD matKey = getMaterialKey(mat);
<@if HIFI_USE_SHADOW or HIFI_USE_UNLIT@>
    <@if not HIFI_USE_MTOON@>
        <$fetchMaterialTexturesCoord0(matKey, _texCoord0, albedoTex)$>
    <@else@>
        <$fetchMToonMaterialTexturesCoord0(matKey, _texCoord0, albedoTex)$>
    <@endif@>

        float cutoff = getMaterialOpacityCutoff(mat);
    <@if HIFI_USE_TRANSLUCENT@>
        float opacity = getMaterialOpacity(mat);
        <@if not HIFI_USE_MTOON@>
            opacity *= _color.a;
        <@endif@>
        <$evalMaterialOpacity(albedoTex.a, cutoff, opacity, matKey, opacity)$>;
        <$discardInvisible(opacity)$>;
    <@else@>
        float opacity = 1.0;
        <$evalMaterialOpacityMask(albedoTex.a, cutoff, opacity, matKey, opacity)$>;
        <$discardTransparent(opacity)$>;
    <@endif@>

    <@if not HIFI_USE_SHADOW@>
            vec3 albedo = getMaterialAlbedo(mat);
            <$evalMaterialAlbedo(albedoTex, albedo, matKey, albedo)$>;
            <@if not HIFI_USE_MTOON@>
                albedo *= _color.rgb;
            <@endif@>
        <@if HIFI_USE_FADE@>
                albedo += fadeEmissive;
        <@endif@>
    <@endif@>

    <@if HIFI_USE_SHADOW@>
            _fragColor0 = vec4(1.0);
    <@elif HIFI_USE_TRANSLUCENT or HIFI_USE_FORWARD@>
            _fragColor0 = vec4(albedo * isUnlitEnabled(), opacity);
    <@else@>
            packDeferredFragmentUnlit(
                evalFrontOrBackFaceNormal(normalize(_normalWS)),
                opacity,
                albedo * isUnlitEnabled());
    <@endif@>
<@elif HIFI_USE_MTOON@>
        vec3 uvScrollSpeed = getMaterialUVScrollSpeed(mat);
        float time = getMaterialTime(mat);
    <@if HIFI_USE_NORMALMAP@>
        <$fetchMToonMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, normalTex, shadeTex, emissiveTex, shadingShiftTex, rimTex, uvScrollSpeed, time)$>
    <@else@>
        <$fetchMToonMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, _SCRIBE_NULL, shadeTex, emissiveTex, shadingShiftTex, rimTex, uvScrollSpeed, time)$>
    <@endif@>

        float cutoff = getMaterialOpacityCutoff(mat);
        <@if HIFI_USE_TRANSLUCENT@>
            float opacity = getMaterialOpacity(mat);
            <$evalMaterialOpacity(albedoTex.a, cutoff, opacity, matKey, opacity)$>;
            <$discardInvisible(opacity)$>;
        <@else@>
            float opacity = 1.0;
            <$evalMaterialOpacityMask(albedoTex.a, cutoff, opacity, matKey, opacity)$>;
            <$discardTransparent(opacity)$>;
        <@endif@>

        vec3 albedo = getMaterialAlbedo(mat);
        <$evalMaterialAlbedo(albedoTex, albedo, matKey, albedo)$>;

        vec3 emissive = getMaterialEmissive(mat);
        <$evalMaterialEmissive(emissiveTex, emissive, matKey, emissive)$>;

    <@if HIFI_USE_NORMALMAP@>
            vec3 fragNormalWS;
            <$evalMaterialNormalLOD(_positionES, normalTex, _normalWS, _tangentWS, fragNormalWS)$>
    <@else@>
            vec3 fragNormalWS = _normalWS;
    <@endif@>
        fragNormalWS = evalFrontOrBackFaceNormal(normalize(fragNormalWS));

        vec3 shade = getMaterialShade(mat);
        <$evalMaterialShade(shadeTex, shade, matKey, shade)$>;

        float shadingShift = getMaterialShadingShift(mat);
        <$evalMaterialShadingShift(shadingShiftTex, shadingShift, matKey, shadingShift)$>;

        TransformCamera cam = getTransformCamera();
        float metallic = DEFAULT_METALLIC;
        vec3 fresnel = getFresnelF0(metallic, albedo);

        vec4 color = vec4(evalGlobalLightingAlphaBlendedMToon(
            cam._viewInverse, 1.0, _positionES.xyz, fragNormalWS,
            albedo, fresnel, metallic, emissive, DEFAULT_ROUGHNESS, opacity,
            shade, shadingShift, getMaterialShadingToony(mat), getMaterialMatcap(mat), getMaterialParametricRim(mat),
            getMaterialParametricRimFresnelPower(mat), getMaterialParametricRimLift(mat), rimTex, getMaterialRimLightingMix(mat), matKey), opacity);

        <@if HIFI_USE_FORWARD or HIFI_USE_TRANSLUCENT@>
            _fragColor0 = isUnlitEnabled() * vec4(color.rgb
            <@if HIFI_USE_FADE@>
                    + fadeEmissive
            <@endif@>
                , color.a);
        <@else@>
            packDeferredFragmentUnlit(
                fragNormalWS,
                1.0,
                color.rgb
            <@if HIFI_USE_FADE@>
                    + fadeEmissive
            <@endif@>
                );
        <@endif@>

<@else@>
    <@if not HIFI_USE_LIGHTMAP@>
        <@if HIFI_USE_NORMALMAP and HIFI_USE_TRANSLUCENT@>
            <$fetchMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, roughnessTex, normalTex, metallicTex, emissiveTex, _SCRIBE_NULL)$>
        <@elif HIFI_USE_NORMALMAP@>
            <$fetchMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, roughnessTex, normalTex, metallicTex, emissiveTex, scatteringTex)$>
        <@elif HIFI_USE_TRANSLUCENT@>
            <$fetchMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, roughnessTex, _SCRIBE_NULL, metallicTex, emissiveTex, _SCRIBE_NULL)$>
        <@else@>
            <$fetchMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, roughnessTex, _SCRIBE_NULL, metallicTex, emissiveTex, scatteringTex)$>
        <@endif@>
            <$fetchMaterialTexturesCoord1(matKey, _texCoord1, occlusionTex)$>
    <@else@>
        <@if HIFI_USE_NORMALMAP@>
            <$fetchMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, roughnessTex, normalTex, metallicTex)$>
        <@else@>
            <$fetchMaterialTexturesCoord0(matKey, _texCoord0, albedoTex, roughnessTex, _SCRIBE_NULL, metallicTex)$>
        <@endif@>
            <$fetchMaterialTexturesCoord1(matKey, _texCoord1, _SCRIBE_NULL, lightmap)$>
    <@endif@>
    
        float cutoff = getMaterialOpacityCutoff(mat);
    <@if HIFI_USE_TRANSLUCENT@>
        float opacity = getMaterialOpacity(mat) * _color.a;
        <$evalMaterialOpacity(albedoTex.a, cutoff, opacity, matKey, opacity)$>;
        <$discardInvisible(opacity)$>;
    <@else@>
        float opacity = 1.0;
        <$evalMaterialOpacityMask(albedoTex.a, cutoff, opacity, matKey, opacity)$>;
        <$discardTransparent(opacity)$>;
    <@endif@>

        vec3 albedo = getMaterialAlbedo(mat);
        <$evalMaterialAlbedo(albedoTex, albedo, matKey, albedo)$>;
        albedo *= _color.rgb;

        float roughness = getMaterialRoughness(mat);
        <$evalMaterialRoughness(roughnessTex, roughness, matKey, roughness)$>;

        float metallic = getMaterialMetallic(mat);
        <$evalMaterialMetallic(metallicTex, metallic, matKey, metallic)$>;

    <@if not HIFI_USE_LIGHTMAP@>
            vec3 emissive = getMaterialEmissive(mat);
            <$evalMaterialEmissive(emissiveTex, emissive, matKey, emissive)$>;

            float occlusion = DEFAULT_OCCLUSION;
            <$evalMaterialOcclusion(occlusionTex, matKey, occlusion)$>;

        <@if not HIFI_USE_TRANSLUCENT@>
                float scattering = getMaterialScattering(mat);
                <$evalMaterialScattering(scatteringTex, scattering, matKey, scattering)$>;
        <@endif@>
    <@endif@>

    <@if HIFI_USE_NORMALMAP@>
            vec3 fragNormalWS;
            <$evalMaterialNormalLOD(_positionES, normalTex, _normalWS, _tangentWS, fragNormalWS)$>
    <@else@>
            vec3 fragNormalWS = _normalWS;
    <@endif@>
        fragNormalWS = evalFrontOrBackFaceNormal(normalize(fragNormalWS));

    <@if HIFI_USE_FORWARD@>
        TransformCamera cam = getTransformCamera();
        vec3 fresnel = getFresnelF0(metallic, albedo);
        <@if not HIFI_USE_TRANSLUCENT@>
            <@if not HIFI_USE_LIGHTMAP@>
                vec4 color = vec4(evalSkyboxGlobalColor(
                    cam._viewInverse,
                    1.0,
                    occlusion,
                    _positionES.xyz,
                    fragNormalWS,
                    albedo,
                    fresnel,
                    metallic,
                    roughness),
                    opacity);
                color.rgb += emissive * isEmissiveEnabled();
                _fragColor0 = color;
            <@else@>
                _fragColor0 = vec4(evalLightmappedColor(
                    cam._viewInverse,
                    1.0,
                    DEFAULT_OCCLUSION,
                    fragNormalWS,
                    albedo,
                    lightmap),
                    opacity);
            <@endif@>
        <@else@>
            <@if not HIFI_USE_LIGHTMAP@>
                _fragColor0 =  vec4(evalGlobalLightingAlphaBlended(
                    cam._viewInverse,
                    1.0,
                    occlusion,
                    _positionES.xyz,
                    fragNormalWS,
                    albedo,
                    fresnel,
                    metallic,
                    emissive,
                    roughness, opacity),
                    opacity);
            <@else@>
                _fragColor0 = vec4(evalLightmappedColor(
                cam._viewInverse,
                1.0,
                DEFAULT_OCCLUSION,
                fragNormalWS,
                albedo,
                lightmap),
                opacity);
            <@endif@>
        <@endif@>
    <@else@>
        <@if not HIFI_USE_TRANSLUCENT@>
            <@if not HIFI_USE_LIGHTMAP@>
                packDeferredFragment(
                    fragNormalWS,
                    opacity,
                    albedo,
                    roughness,
                    metallic,
                    emissive
                <@if HIFI_USE_FADE@>
                        + fadeEmissive
                <@endif@>
                    ,
                    occlusion,
                    scattering);
            <@else@>
                packDeferredFragmentLightmap(
                    fragNormalWS,
                    evalOpaqueFinalAlpha(getMaterialOpacity(mat), opacity),
                    albedo,
                    roughness,
                    metallic,
                    lightmap
                <@if HIFI_USE_FADE@>
                        + fadeEmissive
                <@endif@>
                    );
            <@endif@>
        <@else@>
            TransformCamera cam = getTransformCamera();
            <@if not HIFI_USE_LIGHTMAP@>
                vec3 fresnel = getFresnelF0(metallic, albedo);

                vec3 fragPositionWS = _positionWS.xyz;
                vec3 fragToEyeWS = cam._viewInverse[3].xyz - fragPositionWS;
                vec3 fragToEyeDirWS = normalize(fragToEyeWS);
                SurfaceData surfaceWS = initSurfaceData(roughness, fragNormalWS, fragToEyeDirWS);

                vec4 localLighting = vec4(0.0);
                <$fetchClusterInfo(_positionWS)$>;
                if (hasLocalLights(numLights, clusterPos, dims)) {
                    localLighting = evalLocalLighting(cluster, numLights, fragPositionWS, surfaceWS,
                                                      metallic, fresnel, albedo, 0.0,
                                                      vec4(0), vec4(0), opacity);
                }

                _fragColor0 = vec4(evalGlobalLightingAlphaBlended(
                    cam._viewInverse,
                    1.0,
                    occlusion,
                    _positionES.xyz,
                    fragNormalWS,
                    albedo,
                    fresnel,
                    metallic,
                    emissive
                <@if HIFI_USE_FADE@>
                        + fadeEmissive
                <@endif@>
                    ,
                    surfaceWS, opacity, localLighting.rgb),
                    opacity);
            <@else@>
                _fragColor0 = vec4(evalLightmappedColor(
                    cam._viewInverse,
                    1.0,
                    DEFAULT_OCCLUSION,
                    fragNormalWS,
                    albedo,
                    lightmap),
                    opacity);
            <@endif@>
        <@endif@>
    <@endif@>
<@endif@>
}
