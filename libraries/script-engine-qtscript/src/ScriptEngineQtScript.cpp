//
//  ScriptEngineQtScript.cpp
//  libraries/script-engine-qtscript/src
//
//  Created by Brad Hefta-Gaub on 12/14/13.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

#include "ScriptEngineQtScript.h"

#include <chrono>
#include <thread>

#include <QtCore/QCoreApplication>
#include <QtCore/QEventLoop>
#include <QtCore/QFileInfo>
#include <QtCore/QTimer>
#include <QtCore/QThread>
#include <QtCore/QRegularExpression>

#include <QtCore/QFuture>
#include <QtConcurrent/QtConcurrentRun>

#include <QtWidgets/QMainWindow>
#include <QtWidgets/QApplication>
#include <QtWidgets/QMenuBar>
#include <QtWidgets/QMenu>

#include <QtNetwork/QNetworkRequest>
#include <QtNetwork/QNetworkReply>

#include <QtScript/QScriptContextInfo>
#include <QtScript/QScriptValue>
#include <QtScript/QScriptValueIterator>

#include <QtScriptTools/QScriptEngineDebugger>

#include <shared/LocalFileAccessGate.h>
#include <shared/QtHelpers.h>
#include <shared/AbstractLoggerInterface.h>
//#include <AudioConstants.h>
//#include <AudioEffectOptions.h>
//#include <AvatarData.h>
//#include <DebugDraw.h>
//#include <EntityScriptingInterface.h>
//#include <MessagesClient.h>
//#include <NetworkAccessManager.h>
//#include <PathUtils.h>
//#include <ResourceScriptingInterface.h>
//#include <UserActivityLoggerScriptingInterface.h>
//#include <NodeList.h>
//#include <ScriptAvatarData.h>
//#include <udt/PacketHeaders.h>
//#include <UUID.h>

//#include <controllers/ScriptingInterface.h>
//#include <AnimationObject.h>
#include <ScriptEngineLogging.h>

//#include "ArrayBufferViewClass.h"
//#include "AssetScriptingInterface.h"
//#include "BatchLoader.h"
//#include "BaseScriptEngine.h"
//#include "DataViewClass.h"
//#include "EventTypes.h"
//#include "FileScriptingInterface.h" // unzip project
//#include "MenuItemProperties.h"
//#include "ScriptAudioInjector.h"
//#include "ScriptAvatarData.h"
//#include "ScriptCache.h"
//#include "TypedArrays.h"
//#include "XMLHttpRequestClass.h"
//#include "WebSocketClass.h"
//#include "RecordingScriptingInterface.h"
//#include "ScriptEngines.h"
//#include "StackTestScriptingInterface.h"
//#include "ModelScriptingInterface.h"

//#include <Profile.h>

//#include "../../midi/src/Midi.h"        // FIXME why won't a simpler include work?
//#include "MIDIEvent.h"

//#include "SettingHandle.h"
//#include <AddressManager.h>
//#include <NetworkingConstants.h>
//#include <ThreadHelpers.h>

static const int MAX_MODULE_ID_LENGTH { 4096 };
static const int MAX_DEBUG_VALUE_LENGTH { 80 };

static const QScriptEngine::QObjectWrapOptions DEFAULT_QOBJECT_WRAP_OPTIONS =
                QScriptEngine::ExcludeDeleteLater | QScriptEngine::ExcludeChildObjects;
static const QScriptValue::PropertyFlags READONLY_PROP_FLAGS { QScriptValue::ReadOnly | QScriptValue::Undeletable };
static const QScriptValue::PropertyFlags READONLY_HIDDEN_PROP_FLAGS { READONLY_PROP_FLAGS | QScriptValue::SkipInEnumeration };

static const bool HIFI_AUTOREFRESH_FILE_SCRIPTS { true };

Q_DECLARE_METATYPE(QScriptEngine::FunctionSignature)
int functionSignatureMetaID = qRegisterMetaType<QScriptEngine::FunctionSignature>();

int scriptEnginePointerMetaID = qRegisterMetaType<ScriptEngineQtScriptPointer>();

static QScriptValue debugPrint(QScriptContext* context, QScriptEngine* engine) {
    // assemble the message by concatenating our arguments
    QString message = "";
    for (int i = 0; i < context->argumentCount(); i++) {
        if (i > 0) {
            message += " ";
        }
        message += context->argument(i).toString();
    }

    // was this generated by a script engine? If we don't recognize it then send the message and exit
    ScriptEngineQtScript* scriptEngine = qobject_cast<ScriptEngineQtScript*>(engine);
    if (!scriptEngine) {
        qCDebug(scriptengine_script, "%s", qUtf8Printable(message));
        return QScriptValue();
    }

    QString filename;
    auto scriptManager = scriptEngine->manager();
    if (scriptManager) {
        filename = scriptManager->getFilename();
    }

    // This message was sent by one of our script engines, let's try to see if we can find the source.
    // Note that the first entry in the backtrace should be "print" and is somewhat useless to us
    AbstractLoggerInterface* loggerInterface = AbstractLoggerInterface::get();
    if (loggerInterface && loggerInterface->showSourceDebugging()) {
        QScriptContext* userContext = context;
        while (userContext && QScriptContextInfo(userContext).functionType() == QScriptContextInfo::NativeFunction) {
            userContext = userContext->parentContext();
        }
        QString location;
        if (userContext) {
            QScriptContextInfo contextInfo(userContext);
            QString fileName = contextInfo.fileName();
            int lineNumber = contextInfo.lineNumber();
            QString functionName = contextInfo.functionName();
    
            location = functionName;
            if (!fileName.isEmpty()) {
                if (location.isEmpty()) {
                    location = fileName;
                } else {
                    location = QString("%1 at %2").arg(location).arg(fileName);
                }
            }
            if (lineNumber != -1) {
                location = QString("%1:%2").arg(location).arg(lineNumber);
            }
        }
        if (location.isEmpty()) {
            location = filename;
        }
    
        // give the script engine a chance to notify the system about this message
        scriptEngine->print(message);
    
        // send the message to debug log
        qCDebug(scriptengine_script, "[%s] %s", qUtf8Printable(location), qUtf8Printable(message));
    } else {
        scriptEngine->print(message);
        // prefix the script engine name to help disambiguate messages in the main debug log
        qCDebug(scriptengine_script, "[%s] %s", qUtf8Printable(filename), qUtf8Printable(message));
    }

    return QScriptValue();
}

ScriptEngineQtScript::ScriptEngineQtScript(ScriptManager* scriptManager) :
    BaseScriptEngine(),
    _manager(scriptManager),
    _arrayBufferClass(new ArrayBufferClass(this))
{
    if (_manager) {
        connect(this, &QScriptEngine::signalHandlerException, this, [this](const QScriptValue& exception) {
            if (Base::hasUncaughtException()) {
                // the engine's uncaughtException() seems to produce much better stack traces here
                emit _manager->unhandledException(Base::cloneUncaughtException("signalHandlerException"));
                Base::clearExceptions();
            } else {
                // ... but may not always be available -- so if needed we fallback to the passed exception
                emit _manager->unhandledException(exception);
            }
        }, Qt::DirectConnection);
    }

    setProcessEventsInterval(MSECS_PER_SECOND);
}

bool ScriptEngineQtScript::isDebugMode() const {
#if defined(DEBUG)
    return true;
#else
    return false;
#endif
}

ScriptEngineQtScript::~ScriptEngineQtScript() {}

void ScriptEngineQtScript::disconnectNonEssentialSignals() {
    disconnect();
    QThread* workerThread;
    // Ensure the thread should be running, and does exist
    if (_isRunning && _isThreaded && (workerThread = Base::thread())) {
        connect(this, &QObject::destroyed, workerThread, &QThread::quit);
        connect(workerThread, &QThread::finished, workerThread, &QObject::deleteLater);
    }
}

void ScriptEngineQtScript::executeOnScriptThread(std::function<void()> function, const Qt::ConnectionType& type ) {
    if (QThread::currentThread() != Base::thread()) {
        QMetaObject::invokeMethod(this, "executeOnScriptThread", type, Q_ARG(std::function<void()>, function));
        return;
    }

    function();
}

void ScriptEngineQtScript::registerValue(const QString& valueName, QScriptValue value) {
    if (QThread::currentThread() != Base::thread()) {
#ifdef THREAD_DEBUGGING
        qCDebug(scriptengine) << "*** WARNING *** ScriptEngineQtScript::registerValue() called on wrong thread [" << QThread::currentThread() << "], invoking on correct thread [" << thread() << "]";
#endif
        QMetaObject::invokeMethod(this, "registerValue",
                                  Q_ARG(const QString&, valueName),
                                  Q_ARG(QScriptValue, value));
        return;
    }

    QStringList pathToValue = valueName.split(".");
    int partsToGo = pathToValue.length();
    QScriptValue partObject = globalObject();

    for (const auto& pathPart : pathToValue) {
        partsToGo--;
        if (!partObject.property(pathPart).isValid()) {
            if (partsToGo > 0) {
                //QObject *object = new QObject;
                QScriptValue partValue = newArray(); //newQObject(object, QScriptEngine::ScriptOwnership);
                partObject.setProperty(pathPart, partValue);
            } else {
                partObject.setProperty(pathPart, value);
            }
        }
        partObject = partObject.property(pathPart);
    }
}

void ScriptEngineQtScript::registerGlobalObject(const QString& name, QObject* object) {
    if (QThread::currentThread() != Base::thread()) {
#ifdef THREAD_DEBUGGING
        qCDebug(scriptengine) << "*** WARNING *** ScriptEngineQtScript::registerGlobalObject() called on wrong thread [" << QThread::currentThread() << "], invoking on correct thread [" << thread() << "]  name:" << name;
#endif
        QMetaObject::invokeMethod(this, "registerGlobalObject",
                                  Q_ARG(const QString&, name),
                                  Q_ARG(QObject*, object));
        return;
    }
#ifdef THREAD_DEBUGGING
    qCDebug(scriptengine) << "ScriptEngineQtScript::registerGlobalObject() called on thread [" << QThread::currentThread() << "] name:" << name;
#endif

    if (!Base::globalObject().property(name).isValid()) {
        if (object) {
            QScriptValue value = Base::newQObject(object, QScriptEngine::QtOwnership, DEFAULT_QOBJECT_WRAP_OPTIONS);
            Base::globalObject().setProperty(name, value);
        } else {
            Base::globalObject().setProperty(name, QScriptValue());
        }
    }
}

void ScriptEngineQtScript::registerFunction(const QString& name, QScriptEngine::FunctionSignature functionSignature, int numArguments) {
    if (QThread::currentThread() != Base::thread()) {
#ifdef THREAD_DEBUGGING
        qCDebug(scriptengine) << "*** WARNING *** ScriptEngineQtScript::registerFunction() called on wrong thread [" << QThread::currentThread() << "], invoking on correct thread [" << thread() << "] name:" << name;
#endif
        QMetaObject::invokeMethod(this, "registerFunction",
                                  Q_ARG(const QString&, name),
                                  Q_ARG(QScriptEngine::FunctionSignature, functionSignature),
                                  Q_ARG(int, numArguments));
        return;
    }
#ifdef THREAD_DEBUGGING
    qCDebug(scriptengine) << "ScriptEngineQtScript::registerFunction() called on thread [" << QThread::currentThread() << "] name:" << name;
#endif

    QScriptValue scriptFun = Base::newFunction(functionSignature, numArguments);
    Base::globalObject().setProperty(name, scriptFun);
}

void ScriptEngineQtScript::registerFunction(const QString& parent, const QString& name, QScriptEngine::FunctionSignature functionSignature, int numArguments) {
    if (QThread::currentThread() != Base::thread()) {
#ifdef THREAD_DEBUGGING
        qCDebug(scriptengine) << "*** WARNING *** ScriptEngineQtScript::registerFunction() called on wrong thread [" << QThread::currentThread() << "], invoking on correct thread [" << thread() << "] parent:" << parent << "name:" << name;
#endif
        QMetaObject::invokeMethod(this, "registerFunction",
                                  Q_ARG(const QString&, name),
                                  Q_ARG(QScriptEngine::FunctionSignature, functionSignature),
                                  Q_ARG(int, numArguments));
        return;
    }
#ifdef THREAD_DEBUGGING
    qCDebug(scriptengine) << "ScriptEngineQtScript::registerFunction() called on thread [" << QThread::currentThread() << "] parent:" << parent << "name:" << name;
#endif

    QScriptValue object = Base::globalObject().property(parent);
    if (object.isValid()) {
        QScriptValue scriptFun = Base::newFunction(functionSignature, numArguments);
        object.setProperty(name, scriptFun);
    }
}

void ScriptEngineQtScript::registerGetterSetter(const QString& name, QScriptEngine::FunctionSignature getter,
                                        QScriptEngine::FunctionSignature setter, const QString& parent) {
    if (QThread::currentThread() != Base::thread()) {
#ifdef THREAD_DEBUGGING
        qCDebug(scriptengine) << "*** WARNING *** ScriptEngineQtScript::registerGetterSetter() called on wrong thread [" << QThread::currentThread() << "], invoking on correct thread [" << thread() << "] "
            " name:" << name << "parent:" << parent;
#endif
        QMetaObject::invokeMethod(this, "registerGetterSetter",
                                  Q_ARG(const QString&, name),
                                  Q_ARG(QScriptEngine::FunctionSignature, getter),
                                  Q_ARG(QScriptEngine::FunctionSignature, setter),
                                  Q_ARG(const QString&, parent));
        return;
    }
#ifdef THREAD_DEBUGGING
    qCDebug(scriptengine) << "ScriptEngineQtScript::registerGetterSetter() called on thread [" << QThread::currentThread() << "] name:" << name << "parent:" << parent;
#endif

    QScriptValue setterFunction = Base::newFunction(setter, 1);
    QScriptValue getterFunction = Base::newFunction(getter);

    if (!parent.isNull() && !parent.isEmpty()) {
        QScriptValue object = Base::globalObject().property(parent);
        if (object.isValid()) {
            object.setProperty(name, setterFunction, QScriptValue::PropertySetter);
            object.setProperty(name, getterFunction, QScriptValue::PropertyGetter);
        }
    } else {
        Base::globalObject().setProperty(name, setterFunction, QScriptValue::PropertySetter);
        Base::globalObject().setProperty(name, getterFunction, QScriptValue::PropertyGetter);
    }
}

// this is not redundant -- the version in BaseScriptEngine is specifically not Q_INVOKABLE
QScriptValue ScriptEngineQtScript::evaluateInClosure(const QScriptValue& closure, const QScriptProgram& program) {
    return BaseScriptEngine::evaluateInClosure(closure, program);
}

QScriptValue ScriptEngineQtScript::evaluate(const QString& sourceCode, const QString& fileName, int lineNumber) {
    QSharedPointer<ScriptEngines> scriptEngines(_scriptEngines);
    if (!scriptEngines || scriptEngines->isStopped()) {
        return QScriptValue(); // bail early
    }

    if (QThread::currentThread() != Base::thread()) {
        QScriptValue result;
#ifdef THREAD_DEBUGGING
        qCDebug(scriptengine) << "*** WARNING *** ScriptEngineQtScript::evaluate() called on wrong thread [" << QThread::currentThread() << "], invoking on correct thread [" << thread() << "] "
            "sourceCode:" << sourceCode << " fileName:" << fileName << "lineNumber:" << lineNumber;
#endif
        BLOCKING_INVOKE_METHOD(this, "evaluate",
                                  Q_RETURN_ARG(QScriptValue, result),
                                  Q_ARG(const QString&, sourceCode),
                                  Q_ARG(const QString&, fileName),
                                  Q_ARG(int, lineNumber));
        return result;
    }

    // Check syntax
    auto syntaxError = Base::lintScript(sourceCode, fileName);
    if (syntaxError.isError()) {
        if (!Base::isEvaluating()) {
            syntaxError.setProperty("detail", "evaluate");
        }
        Base::raiseException(syntaxError);
        Base::maybeEmitUncaughtException("lint");
        return syntaxError;
    }
    QScriptProgram program { sourceCode, fileName, lineNumber };
    if (program.isNull()) {
        // can this happen?
        auto err = Base::makeError("could not create QScriptProgram for " + fileName);
        Base::raiseException(err);
        Base::maybeEmitUncaughtException("compile");
        return err;
    }

    QScriptValue result;
    {
        result = BaseScriptEngine::evaluate(program);
        Base::maybeEmitUncaughtException("evaluate");
    }
    return result;
}

void ScriptEngineQtScript::updateMemoryCost(const qint64& deltaSize) {
    if (deltaSize > 0) {
        // We've patched qt to fix https://highfidelity.atlassian.net/browse/BUGZ-46 on mac and windows only.
#if defined(Q_OS_WIN) || defined(Q_OS_MAC)
        reportAdditionalMemoryCost(deltaSize);
#endif
    }
}

void ScriptEngineQtScript::print(const QString& message) {
    QString filename;
    auto scriptManager = manager();
    if (scriptManager) {
        filename = scriptManager->getFilename();
    }

    emit printedMessage(message, filename);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ScriptEngine implementation
/*
ScriptValuePointer ScriptEngineQtScript::globalObject() const {
    return Base::globalObject();
}

ScriptManager* ScriptEngineQtScript::manager() const {
}

ScriptValuePointer ScriptEngineQtScript::newArray(uint length) {
    return Base::newArray(length);
}

ScriptValuePointer ScriptEngineQtScript::newArrayBuffer(const QByteArray& message) {
    QScriptValue data = Base::newVariant(QVariant::fromValue(message));
    QScriptValue ctor = Base::globalObject().property("ArrayBuffer");
    auto array = qscriptvalue_cast<ArrayBufferClass*>(ctor.data());
    if (!array) {
        return undefinedValue()
    }
    return Base::newObject(array, data);
}

ScriptValuePointer ScriptEngineQtScript::newObject() {
    return Base::newObject();
}

ScriptProgramPointer ScriptEngineQtScript::newProgram(const QString& sourceCode, const QString& fileName) {
}

ScriptValuePointer ScriptEngineQtScript::newQObject(QObject* obj) {
}

ScriptValuePointer ScriptEngineQtScript::newValue(bool value) {
}

ScriptValuePointer ScriptEngineQtScript::newValue(int value) {
}

ScriptValuePointer ScriptEngineQtScript::newValue(uint value) {
}

ScriptValuePointer ScriptEngineQtScript::newValue(double value) {
}

ScriptValuePointer ScriptEngineQtScript::newValue(const QString& value) {
}

ScriptValuePointer ScriptEngineQtScript::newValue(const QLatin1String& value) {
}

ScriptValuePointer ScriptEngineQtScript::newValue(const char* value) {
}

ScriptValuePointer ScriptEngineQtScript::newVariant(const QVariant& value) {
}

ScriptValuePointer ScriptEngineQtScript::nullValue() {
    return Base::nullValue();
}

void ScriptEngineQtScript::setDefaultPrototype(int metaTypeId, const ScriptValuePointer& prototype) {
}

ScriptValuePointer ScriptEngineQtScript::undefinedValue() {
    return Base::undefinedValue();
}
*/